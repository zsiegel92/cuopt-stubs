import _cython_3_1_6
import enum
from cuopt.linear_programming.solver_settings.solver_settings import PDLPSolverMode as PDLPSolverMode, SolverSettings as SolverSettings
from cuopt.utilities.exception_handler import InputValidationError as InputValidationError
from typing import Callable, ClassVar

BatchSolve: _cython_3_1_6.cython_function_or_method
Solve: _cython_3_1_6.cython_function_or_method
__test__: dict
get_data_ptr: _cython_3_1_6.cython_function_or_method
type_cast: _cython_3_1_6.cython_function_or_method

class ErrorStatus(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    OutOfMemoryError: ClassVar[ErrorStatus] = ...
    RuntimeError: ClassVar[ErrorStatus] = ...
    Success: ClassVar[ErrorStatus] = ...
    ValidationError: ClassVar[ErrorStatus] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class LPTerminationStatus(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    DualInfeasible: ClassVar[LPTerminationStatus] = ...
    IterationLimit: ClassVar[LPTerminationStatus] = ...
    NoTermination: ClassVar[LPTerminationStatus] = ...
    NumericalError: ClassVar[LPTerminationStatus] = ...
    Optimal: ClassVar[LPTerminationStatus] = ...
    PrimalFeasible: ClassVar[LPTerminationStatus] = ...
    PrimalInfeasible: ClassVar[LPTerminationStatus] = ...
    TimeLimit: ClassVar[LPTerminationStatus] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class MILPTerminationStatus(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    FeasibleFound: ClassVar[MILPTerminationStatus] = ...
    Infeasible: ClassVar[MILPTerminationStatus] = ...
    NoTermination: ClassVar[MILPTerminationStatus] = ...
    Optimal: ClassVar[MILPTerminationStatus] = ...
    TimeLimit: ClassVar[MILPTerminationStatus] = ...
    Unbounded: ClassVar[MILPTerminationStatus] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""

class ProblemCategory(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    IP: ClassVar[ProblemCategory] = ...
    LP: ClassVar[ProblemCategory] = ...
    MIP: ClassVar[ProblemCategory] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _unhashable_values_map_: ClassVar[dict] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str:
        """Convert to a string according to format_spec."""
